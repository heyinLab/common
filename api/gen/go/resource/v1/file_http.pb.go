// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             (unknown)
// source: resource/v1/file.proto

package resourcev1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationFileServiceBatchGetDownloadUrls = "/resource.v1.FileService/BatchGetDownloadUrls"
const OperationFileServiceBatchGetFileUrls = "/resource.v1.FileService/BatchGetFileUrls"
const OperationFileServiceCheckFileExists = "/resource.v1.FileService/CheckFileExists"
const OperationFileServiceCompleteUpload = "/resource.v1.FileService/CompleteUpload"
const OperationFileServiceDeleteFile = "/resource.v1.FileService/DeleteFile"
const OperationFileServiceGetDownloadUrl = "/resource.v1.FileService/GetDownloadUrl"
const OperationFileServiceGetFile = "/resource.v1.FileService/GetFile"
const OperationFileServiceGetUploadUrl = "/resource.v1.FileService/GetUploadUrl"
const OperationFileServiceInitiateUpload = "/resource.v1.FileService/InitiateUpload"
const OperationFileServiceListFiles = "/resource.v1.FileService/ListFiles"

type FileServiceHTTPServer interface {
	// BatchGetDownloadUrls 批量获取下载URL - 触发浏览器下载
	//
	// BatchGetDownloadUrls - 批量获取文件的下载URL
	//
	// 适用场景：
	// - 用户点击"下载"按钮
	// - 批量导出文件
	// - 文件另存为操作
	//
	// URL特性：
	// - 总是返回预签名URL（包含Content-Disposition响应头）
	// - 触发浏览器下载对话框（而不是在浏览器中展示）
	// - 可自定义下载文件名
	//
	// 与BatchGetFileUrls的区别：
	// - 此接口返回的URL会触发文件下载
	// - BatchGetFileUrls返回的URL用于在线展示
	// - 即使是公开文件，此接口也返回预签名URL（为了Content-Disposition头）
	BatchGetDownloadUrls(context.Context, *BatchGetDownloadUrlsRequest) (*BatchGetDownloadUrlsResponse, error)
	// BatchGetFileUrls 批量获取文件URL - 用于在线展示/播放
	//
	// BatchGetFileUrls - 批量获取文件的访问URL
	//
	// 适用场景：
	// - 图片展示：<img src="url">
	// - 视频播放：<video src="url">
	// - 音频播放：<audio src="url">
	// - PDF预览：<embed src="url">
	//
	// URL类型：
	// - 公开文件（PUBLIC_READ bucket）：返回CDN永久URL或公开访问URL
	// - 私有文件（PRIVATE bucket）：返回预签名URL（有过期时间）
	//
	// 性能优势：
	// - 批量处理：一次请求获取多个文件URL
	// - 并发生成：内部并发处理提升速度
	// - 包含变体：可选返回所有派生图片URL
	//
	// 返回特性：
	// - 部分失败不影响其他文件（success字段标识）
	// - is_public字段标识是否为永久URL
	// - 公开URL可长期缓存，私有URL需定期刷新
	BatchGetFileUrls(context.Context, *BatchGetFileUrlsRequest) (*BatchGetFileUrlsResponse, error)
	// CheckFileExists 检查文件是否存在
	//
	// CheckFileExists - 通过SHA256校验和检查文件是否已存在（秒传）
	//
	// 秒传原理：
	// 1. 上传前计算文件SHA256
	// 2. 调用此接口检查
	// 3. 如果exists=true，直接使用已有文件，无需上传
	//
	// 使用场景：
	// - 大文件上传前检查（节省流量）
	// - 文件去重
	// - 网盘类应用的秒传功能
	//
	// 返回信息：
	// - exists: 是否存在
	// - file: 如果存在，返回文件对象（可直接使用）
	//
	// 示例流程：
	// 1. 用户选择文件
	// 2. 前端计算SHA256
	// 3. 调用CheckFileExists
	// 4. exists=true → 秒传成功，显示"上传完成"
	// 5. exists=false → 调用InitiateUpload正常上传
	CheckFileExists(context.Context, *CheckFileExistsRequest) (*CheckFileExistsResponse, error)
	// CompleteUpload 完成文件上传
	//
	// CompleteUpload - 上传流程的最后一步，用于：
	// 1. 验证文件是否真正上传到云存储
	// 2. 更新文件状态为COMPLETED
	// 3. 记录图片派生处理结果
	// 4. 触发后续处理（如病毒扫描、内容审核等）
	//
	// 调用时机：
	// - 客户端直传到云存储完成后
	// - 收到云存储的200 OK响应后
	//
	// 注意：
	// - 必须在上传成功后调用，否则文件状态保持UPLOADING
	// - 超过24小时未Complete的文件会被自动清理
	CompleteUpload(context.Context, *CompleteUploadRequest) (*FileObject, error)
	// DeleteFile 删除文件
	//
	// DeleteFile - 支持两种删除模式：
	// 1. 软删除（permanent=false）：仅标记删除，可恢复
	// 2. 硬删除（permanent=true）：从云存储永久删除，不可恢复
	//
	// 软删除：
	// - 文件状态变更为DELETED
	// - 文件仍在云存储中
	// - 可通过管理接口恢复
	// - 定期清理（如30天后）
	//
	// 硬删除：
	// - 立即从云存储删除
	// - 数据库记录标记删除
	// - 释放存储空间配额
	// - 不可恢复
	//
	// 使用场景：
	// - 用户删除文件
	// - 清理临时文件
	// - 释放存储空间
	//
	// 注意：
	// - 硬删除需要谨慎，建议先软删除观察一段时间
	// - 删除文件会同时删除所有派生图片
	DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error)
	// GetDownloadUrl 获取下载URL
	//
	// GetDownloadUrl - 生成预签名下载URL，用于：
	// 1. 下载原始文件
	// 2. 下载图片派生变体
	// 3. 实时图片处理（可选）
	//
	// URL特性：
	// - 临时授权（默认1小时有效期）
	// - 无需暴露云存储密钥
	// - 支持自定义下载文件名
	// - 客户端可直接访问（CDN加速）
	//
	// 使用场景：
	// - 文件下载
	// - 图片展示（<img src="...">）
	// - 视频播放
	// - PDF预览
	//
	// 注意：
	// - URL会过期，建议缓存时间小于expires_in
	// - 公开bucket可配置CDN域名，URL永久有效
	GetDownloadUrl(context.Context, *GetDownloadUrlRequest) (*GetDownloadUrlResponse, error)
	// GetFile 获取文件信息
	//
	// GetFile - 查询文件的元数据信息，不包含下载URL
	//
	// 返回信息：
	// - 文件基本信息（文件名、大小、类型）
	// - 状态信息（上传中/已完成/已删除）
	// - 存储信息（对象键、存储类别、加密方式）
	// - 时间信息（创建/更新/过期时间）
	//
	// 使用场景：
	// - 检查文件状态
	// - 获取文件元数据
	// - 验证文件是否存在
	GetFile(context.Context, *GetFileRequest) (*FileObject, error)
	// GetUploadUrl 获取上传URL
	//
	// GetUploadUrl - 为已创建的文件记录生成新的上传URL（重新上传场景）
	//
	// 使用场景：
	// - 上传失败后重试
	// - URL过期后重新获取
	// - 分片上传前获取各分片的上传URL
	//
	// 注意：此接口要求文件记录已存在（通过InitiateUpload创建）
	GetUploadUrl(context.Context, *GetUploadUrlRequest) (*GetUploadUrlResponse, error)
	// InitiateUpload 初始化文件上传
	InitiateUpload(context.Context, *InitiateUploadRequest) (*InitiateUploadResponse, error)
	// ListFiles 列出文件
	// 分页查询指定存储桶中的文件列表
	//
	// 支持过滤条件：
	// - 按状态过滤（status）
	// - 按对象键前缀过滤（prefix）
	//
	// 使用场景：
	// - 文件管理后台
	// - 用户文件列表
	// - 文件浏览器
	//
	// 性能建议：
	// - 建议page_size不超过100
	// - 使用prefix过滤减少结果集
	ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error)
}

func RegisterFileServiceHTTPServer(s *http.Server, srv FileServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/files:initiate", _FileService_InitiateUpload0_HTTP_Handler(srv))
	r.POST("/api/v1/files/{file_id}:upload-url", _FileService_GetUploadUrl0_HTTP_Handler(srv))
	r.POST("/api/v1/files/{file_id}:complete", _FileService_CompleteUpload0_HTTP_Handler(srv))
	r.GET("/api/v1/files/{file_id}", _FileService_GetFile0_HTTP_Handler(srv))
	r.GET("/api/v1/files", _FileService_ListFiles0_HTTP_Handler(srv))
	r.POST("/api/v1/files/{file_id}:download-url", _FileService_GetDownloadUrl0_HTTP_Handler(srv))
	r.DELETE("/api/v1/files/{file_id}", _FileService_DeleteFile0_HTTP_Handler(srv))
	r.POST("/api/v1/files:check", _FileService_CheckFileExists0_HTTP_Handler(srv))
	r.POST("/api/v1/files:batch-urls", _FileService_BatchGetFileUrls0_HTTP_Handler(srv))
	r.POST("/api/v1/files:batch-download-urls", _FileService_BatchGetDownloadUrls0_HTTP_Handler(srv))
}

func _FileService_InitiateUpload0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in InitiateUploadRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceInitiateUpload)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.InitiateUpload(ctx, req.(*InitiateUploadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*InitiateUploadResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_GetUploadUrl0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetUploadUrlRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceGetUploadUrl)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetUploadUrl(ctx, req.(*GetUploadUrlRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetUploadUrlResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_CompleteUpload0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CompleteUploadRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceCompleteUpload)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CompleteUpload(ctx, req.(*CompleteUploadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FileObject)
		return ctx.Result(200, reply)
	}
}

func _FileService_GetFile0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFileRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceGetFile)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFile(ctx, req.(*GetFileRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FileObject)
		return ctx.Result(200, reply)
	}
}

func _FileService_ListFiles0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListFilesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceListFiles)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListFiles(ctx, req.(*ListFilesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListFilesResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_GetDownloadUrl0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetDownloadUrlRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceGetDownloadUrl)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetDownloadUrl(ctx, req.(*GetDownloadUrlRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetDownloadUrlResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_DeleteFile0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteFileRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceDeleteFile)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteFile(ctx, req.(*DeleteFileRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteFileResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_CheckFileExists0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CheckFileExistsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceCheckFileExists)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CheckFileExists(ctx, req.(*CheckFileExistsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CheckFileExistsResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_BatchGetFileUrls0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BatchGetFileUrlsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceBatchGetFileUrls)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchGetFileUrls(ctx, req.(*BatchGetFileUrlsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BatchGetFileUrlsResponse)
		return ctx.Result(200, reply)
	}
}

func _FileService_BatchGetDownloadUrls0_HTTP_Handler(srv FileServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BatchGetDownloadUrlsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationFileServiceBatchGetDownloadUrls)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchGetDownloadUrls(ctx, req.(*BatchGetDownloadUrlsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BatchGetDownloadUrlsResponse)
		return ctx.Result(200, reply)
	}
}

type FileServiceHTTPClient interface {
	// BatchGetDownloadUrls 批量获取下载URL - 触发浏览器下载
	//
	// BatchGetDownloadUrls - 批量获取文件的下载URL
	//
	// 适用场景：
	// - 用户点击"下载"按钮
	// - 批量导出文件
	// - 文件另存为操作
	//
	// URL特性：
	// - 总是返回预签名URL（包含Content-Disposition响应头）
	// - 触发浏览器下载对话框（而不是在浏览器中展示）
	// - 可自定义下载文件名
	//
	// 与BatchGetFileUrls的区别：
	// - 此接口返回的URL会触发文件下载
	// - BatchGetFileUrls返回的URL用于在线展示
	// - 即使是公开文件，此接口也返回预签名URL（为了Content-Disposition头）
	BatchGetDownloadUrls(ctx context.Context, req *BatchGetDownloadUrlsRequest, opts ...http.CallOption) (rsp *BatchGetDownloadUrlsResponse, err error)
	// BatchGetFileUrls 批量获取文件URL - 用于在线展示/播放
	//
	// BatchGetFileUrls - 批量获取文件的访问URL
	//
	// 适用场景：
	// - 图片展示：<img src="url">
	// - 视频播放：<video src="url">
	// - 音频播放：<audio src="url">
	// - PDF预览：<embed src="url">
	//
	// URL类型：
	// - 公开文件（PUBLIC_READ bucket）：返回CDN永久URL或公开访问URL
	// - 私有文件（PRIVATE bucket）：返回预签名URL（有过期时间）
	//
	// 性能优势：
	// - 批量处理：一次请求获取多个文件URL
	// - 并发生成：内部并发处理提升速度
	// - 包含变体：可选返回所有派生图片URL
	//
	// 返回特性：
	// - 部分失败不影响其他文件（success字段标识）
	// - is_public字段标识是否为永久URL
	// - 公开URL可长期缓存，私有URL需定期刷新
	BatchGetFileUrls(ctx context.Context, req *BatchGetFileUrlsRequest, opts ...http.CallOption) (rsp *BatchGetFileUrlsResponse, err error)
	// CheckFileExists 检查文件是否存在
	//
	// CheckFileExists - 通过SHA256校验和检查文件是否已存在（秒传）
	//
	// 秒传原理：
	// 1. 上传前计算文件SHA256
	// 2. 调用此接口检查
	// 3. 如果exists=true，直接使用已有文件，无需上传
	//
	// 使用场景：
	// - 大文件上传前检查（节省流量）
	// - 文件去重
	// - 网盘类应用的秒传功能
	//
	// 返回信息：
	// - exists: 是否存在
	// - file: 如果存在，返回文件对象（可直接使用）
	//
	// 示例流程：
	// 1. 用户选择文件
	// 2. 前端计算SHA256
	// 3. 调用CheckFileExists
	// 4. exists=true → 秒传成功，显示"上传完成"
	// 5. exists=false → 调用InitiateUpload正常上传
	CheckFileExists(ctx context.Context, req *CheckFileExistsRequest, opts ...http.CallOption) (rsp *CheckFileExistsResponse, err error)
	// CompleteUpload 完成文件上传
	//
	// CompleteUpload - 上传流程的最后一步，用于：
	// 1. 验证文件是否真正上传到云存储
	// 2. 更新文件状态为COMPLETED
	// 3. 记录图片派生处理结果
	// 4. 触发后续处理（如病毒扫描、内容审核等）
	//
	// 调用时机：
	// - 客户端直传到云存储完成后
	// - 收到云存储的200 OK响应后
	//
	// 注意：
	// - 必须在上传成功后调用，否则文件状态保持UPLOADING
	// - 超过24小时未Complete的文件会被自动清理
	CompleteUpload(ctx context.Context, req *CompleteUploadRequest, opts ...http.CallOption) (rsp *FileObject, err error)
	// DeleteFile 删除文件
	//
	// DeleteFile - 支持两种删除模式：
	// 1. 软删除（permanent=false）：仅标记删除，可恢复
	// 2. 硬删除（permanent=true）：从云存储永久删除，不可恢复
	//
	// 软删除：
	// - 文件状态变更为DELETED
	// - 文件仍在云存储中
	// - 可通过管理接口恢复
	// - 定期清理（如30天后）
	//
	// 硬删除：
	// - 立即从云存储删除
	// - 数据库记录标记删除
	// - 释放存储空间配额
	// - 不可恢复
	//
	// 使用场景：
	// - 用户删除文件
	// - 清理临时文件
	// - 释放存储空间
	//
	// 注意：
	// - 硬删除需要谨慎，建议先软删除观察一段时间
	// - 删除文件会同时删除所有派生图片
	DeleteFile(ctx context.Context, req *DeleteFileRequest, opts ...http.CallOption) (rsp *DeleteFileResponse, err error)
	// GetDownloadUrl 获取下载URL
	//
	// GetDownloadUrl - 生成预签名下载URL，用于：
	// 1. 下载原始文件
	// 2. 下载图片派生变体
	// 3. 实时图片处理（可选）
	//
	// URL特性：
	// - 临时授权（默认1小时有效期）
	// - 无需暴露云存储密钥
	// - 支持自定义下载文件名
	// - 客户端可直接访问（CDN加速）
	//
	// 使用场景：
	// - 文件下载
	// - 图片展示（<img src="...">）
	// - 视频播放
	// - PDF预览
	//
	// 注意：
	// - URL会过期，建议缓存时间小于expires_in
	// - 公开bucket可配置CDN域名，URL永久有效
	GetDownloadUrl(ctx context.Context, req *GetDownloadUrlRequest, opts ...http.CallOption) (rsp *GetDownloadUrlResponse, err error)
	// GetFile 获取文件信息
	//
	// GetFile - 查询文件的元数据信息，不包含下载URL
	//
	// 返回信息：
	// - 文件基本信息（文件名、大小、类型）
	// - 状态信息（上传中/已完成/已删除）
	// - 存储信息（对象键、存储类别、加密方式）
	// - 时间信息（创建/更新/过期时间）
	//
	// 使用场景：
	// - 检查文件状态
	// - 获取文件元数据
	// - 验证文件是否存在
	GetFile(ctx context.Context, req *GetFileRequest, opts ...http.CallOption) (rsp *FileObject, err error)
	// GetUploadUrl 获取上传URL
	//
	// GetUploadUrl - 为已创建的文件记录生成新的上传URL（重新上传场景）
	//
	// 使用场景：
	// - 上传失败后重试
	// - URL过期后重新获取
	// - 分片上传前获取各分片的上传URL
	//
	// 注意：此接口要求文件记录已存在（通过InitiateUpload创建）
	GetUploadUrl(ctx context.Context, req *GetUploadUrlRequest, opts ...http.CallOption) (rsp *GetUploadUrlResponse, err error)
	// InitiateUpload 初始化文件上传
	InitiateUpload(ctx context.Context, req *InitiateUploadRequest, opts ...http.CallOption) (rsp *InitiateUploadResponse, err error)
	// ListFiles 列出文件
	// 分页查询指定存储桶中的文件列表
	//
	// 支持过滤条件：
	// - 按状态过滤（status）
	// - 按对象键前缀过滤（prefix）
	//
	// 使用场景：
	// - 文件管理后台
	// - 用户文件列表
	// - 文件浏览器
	//
	// 性能建议：
	// - 建议page_size不超过100
	// - 使用prefix过滤减少结果集
	ListFiles(ctx context.Context, req *ListFilesRequest, opts ...http.CallOption) (rsp *ListFilesResponse, err error)
}

type FileServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewFileServiceHTTPClient(client *http.Client) FileServiceHTTPClient {
	return &FileServiceHTTPClientImpl{client}
}

// BatchGetDownloadUrls 批量获取下载URL - 触发浏览器下载
//
// # BatchGetDownloadUrls - 批量获取文件的下载URL
//
// 适用场景：
// - 用户点击"下载"按钮
// - 批量导出文件
// - 文件另存为操作
//
// URL特性：
// - 总是返回预签名URL（包含Content-Disposition响应头）
// - 触发浏览器下载对话框（而不是在浏览器中展示）
// - 可自定义下载文件名
//
// 与BatchGetFileUrls的区别：
// - 此接口返回的URL会触发文件下载
// - BatchGetFileUrls返回的URL用于在线展示
// - 即使是公开文件，此接口也返回预签名URL（为了Content-Disposition头）
func (c *FileServiceHTTPClientImpl) BatchGetDownloadUrls(ctx context.Context, in *BatchGetDownloadUrlsRequest, opts ...http.CallOption) (*BatchGetDownloadUrlsResponse, error) {
	var out BatchGetDownloadUrlsResponse
	pattern := "/api/v1/files:batch-download-urls"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceBatchGetDownloadUrls))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// BatchGetFileUrls 批量获取文件URL - 用于在线展示/播放
//
// # BatchGetFileUrls - 批量获取文件的访问URL
//
// 适用场景：
// - 图片展示：<img src="url">
// - 视频播放：<video src="url">
// - 音频播放：<audio src="url">
// - PDF预览：<embed src="url">
//
// URL类型：
// - 公开文件（PUBLIC_READ bucket）：返回CDN永久URL或公开访问URL
// - 私有文件（PRIVATE bucket）：返回预签名URL（有过期时间）
//
// 性能优势：
// - 批量处理：一次请求获取多个文件URL
// - 并发生成：内部并发处理提升速度
// - 包含变体：可选返回所有派生图片URL
//
// 返回特性：
// - 部分失败不影响其他文件（success字段标识）
// - is_public字段标识是否为永久URL
// - 公开URL可长期缓存，私有URL需定期刷新
func (c *FileServiceHTTPClientImpl) BatchGetFileUrls(ctx context.Context, in *BatchGetFileUrlsRequest, opts ...http.CallOption) (*BatchGetFileUrlsResponse, error) {
	var out BatchGetFileUrlsResponse
	pattern := "/api/v1/files:batch-urls"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceBatchGetFileUrls))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// CheckFileExists 检查文件是否存在
//
// CheckFileExists - 通过SHA256校验和检查文件是否已存在（秒传）
//
// 秒传原理：
// 1. 上传前计算文件SHA256
// 2. 调用此接口检查
// 3. 如果exists=true，直接使用已有文件，无需上传
//
// 使用场景：
// - 大文件上传前检查（节省流量）
// - 文件去重
// - 网盘类应用的秒传功能
//
// 返回信息：
// - exists: 是否存在
// - file: 如果存在，返回文件对象（可直接使用）
//
// 示例流程：
// 1. 用户选择文件
// 2. 前端计算SHA256
// 3. 调用CheckFileExists
// 4. exists=true → 秒传成功，显示"上传完成"
// 5. exists=false → 调用InitiateUpload正常上传
func (c *FileServiceHTTPClientImpl) CheckFileExists(ctx context.Context, in *CheckFileExistsRequest, opts ...http.CallOption) (*CheckFileExistsResponse, error) {
	var out CheckFileExistsResponse
	pattern := "/api/v1/files:check"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceCheckFileExists))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// CompleteUpload 完成文件上传
//
// CompleteUpload - 上传流程的最后一步，用于：
// 1. 验证文件是否真正上传到云存储
// 2. 更新文件状态为COMPLETED
// 3. 记录图片派生处理结果
// 4. 触发后续处理（如病毒扫描、内容审核等）
//
// 调用时机：
// - 客户端直传到云存储完成后
// - 收到云存储的200 OK响应后
//
// 注意：
// - 必须在上传成功后调用，否则文件状态保持UPLOADING
// - 超过24小时未Complete的文件会被自动清理
func (c *FileServiceHTTPClientImpl) CompleteUpload(ctx context.Context, in *CompleteUploadRequest, opts ...http.CallOption) (*FileObject, error) {
	var out FileObject
	pattern := "/api/v1/files/{file_id}:complete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceCompleteUpload))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// DeleteFile 删除文件
//
// DeleteFile - 支持两种删除模式：
// 1. 软删除（permanent=false）：仅标记删除，可恢复
// 2. 硬删除（permanent=true）：从云存储永久删除，不可恢复
//
// 软删除：
// - 文件状态变更为DELETED
// - 文件仍在云存储中
// - 可通过管理接口恢复
// - 定期清理（如30天后）
//
// 硬删除：
// - 立即从云存储删除
// - 数据库记录标记删除
// - 释放存储空间配额
// - 不可恢复
//
// 使用场景：
// - 用户删除文件
// - 清理临时文件
// - 释放存储空间
//
// 注意：
// - 硬删除需要谨慎，建议先软删除观察一段时间
// - 删除文件会同时删除所有派生图片
func (c *FileServiceHTTPClientImpl) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...http.CallOption) (*DeleteFileResponse, error) {
	var out DeleteFileResponse
	pattern := "/api/v1/files/{file_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceDeleteFile))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetDownloadUrl 获取下载URL
//
// GetDownloadUrl - 生成预签名下载URL，用于：
// 1. 下载原始文件
// 2. 下载图片派生变体
// 3. 实时图片处理（可选）
//
// URL特性：
// - 临时授权（默认1小时有效期）
// - 无需暴露云存储密钥
// - 支持自定义下载文件名
// - 客户端可直接访问（CDN加速）
//
// 使用场景：
// - 文件下载
// - 图片展示（<img src="...">）
// - 视频播放
// - PDF预览
//
// 注意：
// - URL会过期，建议缓存时间小于expires_in
// - 公开bucket可配置CDN域名，URL永久有效
func (c *FileServiceHTTPClientImpl) GetDownloadUrl(ctx context.Context, in *GetDownloadUrlRequest, opts ...http.CallOption) (*GetDownloadUrlResponse, error) {
	var out GetDownloadUrlResponse
	pattern := "/api/v1/files/{file_id}:download-url"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceGetDownloadUrl))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetFile 获取文件信息
//
// # GetFile - 查询文件的元数据信息，不包含下载URL
//
// 返回信息：
// - 文件基本信息（文件名、大小、类型）
// - 状态信息（上传中/已完成/已删除）
// - 存储信息（对象键、存储类别、加密方式）
// - 时间信息（创建/更新/过期时间）
//
// 使用场景：
// - 检查文件状态
// - 获取文件元数据
// - 验证文件是否存在
func (c *FileServiceHTTPClientImpl) GetFile(ctx context.Context, in *GetFileRequest, opts ...http.CallOption) (*FileObject, error) {
	var out FileObject
	pattern := "/api/v1/files/{file_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceGetFile))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetUploadUrl 获取上传URL
//
// GetUploadUrl - 为已创建的文件记录生成新的上传URL（重新上传场景）
//
// 使用场景：
// - 上传失败后重试
// - URL过期后重新获取
// - 分片上传前获取各分片的上传URL
//
// 注意：此接口要求文件记录已存在（通过InitiateUpload创建）
func (c *FileServiceHTTPClientImpl) GetUploadUrl(ctx context.Context, in *GetUploadUrlRequest, opts ...http.CallOption) (*GetUploadUrlResponse, error) {
	var out GetUploadUrlResponse
	pattern := "/api/v1/files/{file_id}:upload-url"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceGetUploadUrl))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// InitiateUpload 初始化文件上传
func (c *FileServiceHTTPClientImpl) InitiateUpload(ctx context.Context, in *InitiateUploadRequest, opts ...http.CallOption) (*InitiateUploadResponse, error) {
	var out InitiateUploadResponse
	pattern := "/api/v1/files:initiate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationFileServiceInitiateUpload))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListFiles 列出文件
// 分页查询指定存储桶中的文件列表
//
// 支持过滤条件：
// - 按状态过滤（status）
// - 按对象键前缀过滤（prefix）
//
// 使用场景：
// - 文件管理后台
// - 用户文件列表
// - 文件浏览器
//
// 性能建议：
// - 建议page_size不超过100
// - 使用prefix过滤减少结果集
func (c *FileServiceHTTPClientImpl) ListFiles(ctx context.Context, in *ListFilesRequest, opts ...http.CallOption) (*ListFilesResponse, error) {
	var out ListFilesResponse
	pattern := "/api/v1/files"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationFileServiceListFiles))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
